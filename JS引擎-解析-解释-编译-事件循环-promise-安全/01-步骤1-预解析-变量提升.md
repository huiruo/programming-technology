# 闭包给惰性解析带来的问题,解决方案，预解析：Pre-Parser语法分析器
## 定义
预解析：在当前作用域下,js运行之前，会把带有var和function关键字的事先声明，并在内存中安排好。然后再从上到下执行js语句。

进行预解析时，只验证函数语法是否有效、解析函数声明、确定函数作用域，不生成 AST，而实现预解析的，就是 Pre-Parser 解析器。

预解析只会发生在通过var定义的变量和function上

在解析过程中，对于不是立即执行的函数，只进行预解析（Pre Parser），只有当函数调用时，才对函数进行全量解析。

javascript中的函数： 
　　1、预解析：把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前 
　　2、执行 ：从上到下执行，但有例外(setTimeout,setInterval,ajax中的回调函数，事件中的函数需要触发执行)

### 例子
```javaScript
function foo(a, b) {
    var res = a + b;
    return res;
}

var a = 1;
var c = 2;
foo(1, 2);
```
由于 Scanner 是按字节流从上往下一行行读取代码的，所以 V8 解析器也是从上往下解析代码。当 V8 解析器遇到函数声明 foo 时，发现它不是立即执行，所以会用 Pre-Parser 解析器对其预解析，过程中只会解析函数声明，不会解析函数内部代码，不会为函数内部代码生成 AST。

然后 Ignition 解释器会把 AST 编译为字节码并执行，解释器会按照自上而下的顺序执行代码，先执行 var a = 1;  和 var a = 2; 两个赋值表达式，然后执行函数调用 foo(1, 2) ，这时 Parser 解析器才会继续解析函数内的代码、生成 AST，再交给 Ignition 解释器编译执行。

## 预解析-识别语法错误
`SyntaxError 最为特殊，因为它是 编译阶段 抛出来的错误，如果发生语法错误，JS 代码一行都不会执行。而其他类型的异常都是 执行阶段 的错误，就算报错，也会执行异常之前的脚本。`
```javaScript
const token = "ABC";
console.log(token);

//语法错误: Uncaught SyntaxError: Unexpected token '%'
const newToken = %((token);
```
* 在第一行：发现一个声明了的变量和定义。将这个变量保存在当前作用域中的token的变量中，当前作用域即全局作用域。
* 在第二行：JavaScript引擎发现token变量被引用，引擎首先在当前作用域查找token的变量是否存在，如果存在，则为引用的token变量的声明。
* 在第三行：引擎发现newToken变量被声明以及定义。引擎检查在当前作用域中是否有命名为newToken的变量，如果有，则抛出reference error;如果没有，则在当前作用域存储这个变量。
* 在同一行，引擎也发现了需要引用变量%((token)，但是因为这个变量是以%开头的，变量命名不可以使用保留字，所以抛出syntax error（语法错误）。

## 预解析-变量提升:变量/函数提升
例子来看看在解析阶段提升是怎么发生的，以及提升之后是怎么执行的：
```javaScript
doSomething();

function doSomething(){
	console.log("How you doing?");
}
```
* 在第一行：JavaScript引擎遇到一个叫做doSomething的函数。引擎在当前作用域查找，看是否有doSomething,如果有，则引用这个函数，没有则抛出一个reference error。
* 在解析的过程中引擎发现function doSomething位于当前作用域，这样，就在当前作用域添加对这个变量的引用，然后使整个程序都可以访问到这个变量。
* 最终，doSomething函数打印出字符串How you doing?.

在上述解释中，我们发现代码首先被解析成中介代码以确保变量或者函数（这里既是doSomething)可以在当前作用域被访问。

1.能正常运行:预解析通过，没有语法错误
```javaScript
// doSomething();

function doSomething(){
  var test = 1
	console.log("How you doing?",b);
}
console.log('test:',test)
```

2.报错:编译错误
```javaScript
doSomething();

function doSomething(){
  var test = 1
	console.log("How you doing?",b); // Uncaught ReferenceError: b is not defined
}
console.log('test:',test)
```

3.报错:预解析识别语法报错
```javaScript
function doSomething(){
  var test = 1
  const newToken = %bb; // Unexpected token '%'
}
console.log('test:',test)
```

### 变量提升例子2
1.内部并不会被提升，访问test错误
```javaScript
doSomething();

function doSomething(){
	console.log("How you doing?");
  var test = 1
}
console.log('test:',test) // Uncaught ReferenceError: test is not defined
```

2.提升：test undefined：
```javaScript
doSomething();

function doSomething(){
	console.log("How you doing?");
}

console.log('test:',test) // test: undefined

var test = 1
```

3.正常输出test：
```javaScript
doSomething();

function doSomething(){
	console.log("How you doing?");
}

var test = 1
console.log('test:',test) // test: 1
```

## 预解析和立即执行
定义一个函数想要立即执行，写成如下形式是不可行的，在预解释的时候，它把它分解成两部分来对待，第一部分是fn函数，而第二部分是(),一个匿名函数，执行时会报错。如果小括号带参数，如(2)，虽然不会报错，会打印出来2，但并不能把fn执行，也不能当成参数传递给fn函数。
```javaScript
function fn(){
//代码区
}()  // Uncaught SyntaxError: Unexpected token ')'

function fn(){
//代码区
console.log('run fn')
}(2) // fn并不会执行，但整体会返回2
```

如果你想实现立即执行的函数，可以把要执行的函数放到一对括号里面，`对于JavaScript 来说，括弧()里面不能包含语句，`所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明所以，只要将大括号将代码(包括函数部分和在后面加上一对大括号)全部括起来就可以了。 如下：
```javaScript
(function fn(){
//代码区...
}())
还可以写成：闭包。

(function(){
//代码区...
})();
```
## 预解析需要注意的情况
预解析是发生在当前作用域下的，刚开始的时候，我们预解析的是全局作用域，在js中我们的global就是我们的window。

我们运行函数的时候会生成一个新的私有作用域（每次执行都是新的，执行完成就销毁）这个作用域下我们可以理解为开辟了一个新的内存空间。在这个内存中我们也要执行预解析。当我们的函数执行完成后，这个内存或者作用域就会销毁
　　如果在当前作用域下的一个变量没有预解析，就会向它的上一级去找，直到找到window，如果window下也没有定义，就会报错。所以，在函数内通过var定义的变量是局部变量，没有能过var 定义的变量是全局变量。
　　预解析不会在同一个变量上重复的发生，也就是一个变量如果已经在当前作用域下预解析了，不会再重复解析。

等号右边的function不会进行预解析。
```javaScript
alert(a);
fn();
var a = function fn(){};
第一次打印undefined，第二次报错，未定义，因为预解析的时候，=号右边是不进行预解析的。
```

预解释是不受其它if或者其它判断条件影响的，也就是说，即使条件不成立，我们里面只要有var或者function也会被预解释。
```javaScript
alert(a); //undefined
if(1==2){
　　var a=12;
}
```

## 闭包和预解析
闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures

```javaScript
function foo() {
    var d = 20
    return function inner(a, b) {
        const c = a + b + d
        return c
    }
}
const f = foo()
```
上面这段代码的执行过程：
1. 当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f；
2. 然后 foo 函数执行结束，执行上下文被 V8 销毁；
3. 虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d。

foo 函数的执行上下文虽然被销毁了，但是 inner 函数引用的 foo 函数中的变量却不能被销毁，那么 V8 就需要为这种情况做特殊处理，需要保证即便 foo 函数执行结束，但是 foo 函数中的 d 变量依然保持在内存中，不能随着 foo 函数的执行上下文被销毁掉。

那么怎么处理呢？

在执行 foo 函数的阶段，虽然采取了惰性解析，不会解析和执行 foo 函数中的 inner 函数，但是 V8 还是需要判断 inner 函数是否引用了 foo 函数中的变量，负责处理这个任务的模块叫做预解析器。

### 预解析器如何解决闭包所带来的问题？
预解释不生成 ast，不生成作用域，只是快速查看内部函数是否引用了外部的变量，快速查看是否存在语法错误，这种执行速度非常快。

V8 引入预解析器，当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，目的：
1. 判断当前函数是不是存在一些语法上的错误
2. 检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。

如果预解析的过程中，查看到了引用外部变量，那么V8就会将引用到的变量存放在堆中，并追加一个闭包引用，这样当上层函数执行结束之后，只要闭包突然引用了该变量，那么V8也不会销毁改变量。