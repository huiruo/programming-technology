## 1.闭包: 能够读取其他函数内部变量的函数
要理解闭包，首先必须理解 Javascript 特殊的变量作用域。变量的作用域就是两种：
* 全局变量
* 局部变量

Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。
```javaScript
var n = 999;
function f1(){
  console.log(n); // 999
}

f1();
```

另外，在函数外部自然无法读取函数内的局部变量。
```javaScript
function f1(){　　　　
  var n = 999;
}

console.log(n);
/*
Uncaught ReferenceError: n is not defined
*/
```

### 如何从外部读取局部变量？

```javaScript
function f1() {
  var n = 999;
  return n;
}

var result = f1();
console.log('res:',result());
/*
Uncaught TypeError: result is not a function
*/
```

```javaScript
function f1() {
  var n = 999;
  function f2() {
    console.log(n);
    return n
  }

  return f2;
}

var result = f1();
console.log('res:',result()); // 999
```

就是使用闭包： 就是在一个函数内部创建另一个函数。f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量

`定义：函数外部可以访问函数内部局部变量。`

闭包的本质:

本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。实现在外部访问函数中的变量。
```
由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 定义在一个函数内部的函数。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
```

## 闭包用途
闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
```javaScript
function f1() {
  var n = 999;
  nAdd = function () { n += 1 }
  function f2() {
    alert(n);
  }
  return f2;
}

var result = f1();

result(); // 999
nAdd();
result(); // 100
```

在这段代码中，result 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。

为什么会这样呢 ？

原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

这段代码中另一个值得注意的地方，就是

* "nAdd=function(){ n+=1 }" 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。

* 其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。

五、使用闭包的注意点

* 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

* 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

### 1-2.闭包产生
js中变量的作用域是函数作用域, 在函数执行完后,作用域就会被清理,内存被回收,但是由于闭包函数是建立在函数内部的子函数,子函数可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 即使上级函数执行完后作用域内的值也不会被销毁。

常见创建闭包的方式，在一个函数内部返回一个匿名函数。之所以可以访问内部变量，是因为内部函数的作用域链中包含 fn()的作用域：

执行上下文A以及在A中创建的函数B。当B执行时，如果访问了A中的变量对象，那么闭包就会产生。
```javaScript
function fnTest1() {
    let num = 25
    console.log('被调用')
    return function () {
        return num
    }
}
let fn2 = fnTest1()
console.log(fn2()) // 25
//这证明了，函数 fn 中的局部变量 num 一直保存在内存中，并没有在 fn 调用后被自动清除。
```

面试题： 想每次点击对应目标时弹出对应的数字下标 0~4 ，但实际是无论点击哪个目标都会弹出数字 5。
```javaScript
function onMyLoad() {
  var arr = document.getElementsByTagName("p");
  for (var i = 0; i &lt; arr.length; i++) {
    arr[i].onclick = function () {
      alert(i);
    }
  }
}
```

问题所在：arr 中的每一项的 onclick 均为一个函数实例(Function 对象)，这个函数实例也产生了一个闭包域，这个闭包域引用了外部闭包域的变量，其 function scope 的 closure 对象有个名为 i 的引用，外部闭包域的私有变量内容发生变化，内部闭包域得到的值自然会发生改变。

解决办法一
解决思路：增加若干个对应的闭包域空间(这里采用的是匿名函数)，专门用来存储原先需要引用的内容(下标)，不过只限于基本类型(基本类型值传递，对象类型引用传递)。
```javaScript
//声明一个匿名函数，若传进来的是基本类型则为值传递，故不会对实参产生影响,
//该函数对象有一个本地私有变量 arg(形参) ，该函数的 function scope 的 closure 对象属性有两个引用，一个是 arr，一个是 i
//尽管引用 i 的值随外部改变 ，但本地私有变量(形参) arg 不会受影响，其值在一开始被调用的时候就决定了
for (var i = 0; i &lt; arr.length; i++) {
  (function (arg) {
    arr[i].onclick = function () {
      // onclick 函数实例的 function scope 的 closure 对象属性有一个引用 arg,
      alert(arg);
      //只要 外部空间的 arg 不变，这里的引用值当然不会改变
    }
  })(i); //立刻执行该匿名函数，传递下标 i (实参)
}
```

解决办法二
解决思路：将事件绑定在新增的匿名函数返回的函数上，此时绑定的函数中的 function scope 中的 closure 对象的 引用 arg 是指向将其返回的匿名函数的私有变量 arg
```javaScript
for (var i = 0; i &lt; arr.length; i++) {
  arr[i].onclick = (function (arg) {
    return function () {
      alert(arg);
    }
  })(i);
}
```

使用 ES6 新语法 let 关键字
```javaScript
for (var i = 0; i &lt; arr.length; i++) {
  let j = i; // 创建一个块级变量
  arr[i].onclick = function () {
    alert(j);
  }
}
```

## 闭包面试题1
### 1.闭包面试经典问题
原因是：setTimeout是异步操作不会马上执行，eventloop会等主线机制完成后执行，
需要等待到函数调用栈清空之后才开始执行。即所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。
而这些操作进入队列的顺序，则由设定的延迟时间来决定。
因此在上面这个例子中，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕之后才开始执行。这里的延迟时间，并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。

所以上面的例子执行结果就非常容易理解了。而for是同步执行，因此执行settimeout的时候for循环已经执行完了，结果打印的值为3个3
```javaScript
function testBi() {
    const testArr = [1, 2, 3]
    for (var i = 0; i < testArr.length; i++) {
        setTimeout(function () {
            console.log('闭包题目：', i)
        }, 0)
    }
}
testBi() // 输出 333
```

### 1-2.方法1可使用闭包的方法解决
解决思路：增加若干个对应的闭包域空间(这里采用的是匿名函数)，
专门用来存储原先需要引用的内容(下标)，不过只限于基本类型(基本类型值传递，对象类型引用传递)。

声明一个匿名函数，若传进来的是基本类型则为值传递，故不会对实参产生影响,
该函数对象有一个本地私有变量 arg(形参) ，该函数的 function scope 的 closure 对象属性有两个引用，一个是 arr，一个是 i
尽管引用 i 的值随外部改变 ，但本地私有变量(形参) arg 不会受影响，其值在一开始被调用的时候就决定了

// 而我们想要让输出结果依次执行，我们就必须借助闭包的特性，每次循环时，将i值保存在一个闭包中，当setTimeout中定义的操作执行时，则访问对应闭包保存的i值即可。
```javaScript
function testBi2() {
    const testArr = [1, 2, 3]
    for (var i = 0; i < testArr.length; i++) {
        (function (arg) {       //外部函数
            setTimeout(function () {     //内部函数
                // 只要 外部空间的 arg 不变，这里的引用值当然不会改变
                console.log('闭包题目@：', arg)
            })
        })(i)
    }
}
testBi2() // 输出 1,2,3
```

### 1-3:使用let 解决
```
遍历 i 是通过 let 关键字声明的：通过 let 和 const 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。

在每次的遍历过程中，i 都有一个新值，并且每个值都在循环内的作用域中，使其结果依次输出0,1,2
```
