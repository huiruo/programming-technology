
#### 1-1.前言
```
字符串的一种基本操作就是子字符串查找：给定一段长度为N的文本和一个长度为M 的模式（pattern）字符串，
在文本中找到一个和该模式相符的子字符串。

当你在文本编辑器或是浏览器中查找某个单词时，就是在查找子字符串。
为了更好地理解算法，请记住模式相对于文本是很短的（ 可能等于 100 或者 1000），
而文本相对于模式是很长的（ 可能等于 100 万或者 10 亿）。
在字符串查找中，一般会对模式进行预处理来支持在文本中的快速查找。
```

#### 1-2.进一步分析
```
子字符串查找有一个简单而使用广泛的暴力算法。虽然它在最坏情况下的运行时间与MN成正比，
但是在处理许多应用程序中的字符串时（除了一些变态的情况之外），它的实际运行时间一般与M+N成正比。
```


#### 2-1.暴力子字符串查找算法
```
子字符串查找的一个最显而易见的方法就是在文本中模式可能出现匹配的任何地方检查匹配是否存在。

如左侧框注所示的 search() 方法就是在文本字符串 txt 中查找模式字符串 pat 第一次出现的位置。
这段程序使用了一个指针 i 跟踪文本，一个指针 j 跟踪模式。
对于每个 i，代码首先将 j 重置为 0 并不断将它增大，直至找到了一个不匹配的字符或是模式结束（j==M）为止
```

```
在典型的字符串处理应用程序中，索引 j 增长的机会很少，因此该算法的运行时间与 N 成正比。绝大多数比较在比较
第一个字符时就会产生不匹配。
例如，假设你在这一段文字之中查找 pattern 这个模式字符串。在找到模式字符串的第一次匹配之前共有 191 个单词，
其中只有 7 个的首字母是 p（且没有以 pa 开头的单词）。因此字符比较的总次数为 191+7，也就是说文本中每个字符
平均需要比较 1.036 次。从另一个方面来说，没人能够保证算法总是如此高效。

例如，模式字符串可能以一连串的 A 开头。如果是这样且文本也包含含有一大串 A 的会很慢。
```